# 数据响应式
一旦数据发生变化，我们感知到变化，并立即执行响应
# 如何实现
对象属性拦截(2.x)
```js
Object.defineProperty
```
对象整体代理(3.x  )
```js
Proxy
```
# get和set联动
```js
let data = {}
let _name = "test"
Object.defineProperty(data, 'name', {
get () {
	return _name
},

set (newValue) {
	_name = newValue
}
})
```
# 多个属性
```js
let data = {
	name:'cp',
	height:180,
	age:29
}
1. 由于有多个属性 对象遍历
	1. key代表data对象的每一个属性名
	2. data[key]代表每一个属性的对应的value的值
2. 把对象的属性转换为get和set的形式
Object.keys(data).forEach((key) =>{
	defineReactive(data,key,data[key])
})

function defineReactive(data,key,value){
	// let data
	// let key 
	// let value
	Object.defineProperty(data,key,{
		get(){
			return value
		}
		set(newValue){
			value = newValue
		}
	})
}
```
对象遍历的时候 每遍历一次 调用一次 defineReactive函数，形成了多个独立的函数作用域，在每一个独立的函数作用于中，set和get联动操作的都是独立的value的值
1. 函数定义形参相当于在内部，申明了和形参名字对应的变量，并且初始值为undefined
2. 函数调用传入实参，相当于给内部声明的变量赋值
3. 函数调用完毕，本来应该内部所用的变量都会被回收，但是内部有其他函数使用了当前变量则形成了闭包，不会被回收
4. 内部由于有其他方法引用了value属性，所以defineReactive函数的执行，并不会导致value的销毁，会一直存在
5. 由于闭包的特性，每一个传入下来的value都会常驻内存，相当于上一步的_name 目是 set和get联动
# 闭包
_闭包_ 是由==函数==以及==声明该函数的词法环境==组合而成的。
**闭包**（closure）是一个函数以及其捆绑的周边环境状态（**lexical environment**，**词法环境**）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。
```js
function makeAdder(x) {
  return function(y) {
    return x + y;
  };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);

console.log(add5(2));  // 7
console.log(add10(2)); // 12

```

# vue3
proxy劫持对象整体+惰性处理，defineProperty 逐个属性劫持

# 数据变化反映到视图中
## v-text
1. 先通过查找bom把数据放到相应的dom中显示出来
2. 数据变化之后再次执行把新数据放到相应的dom
## v-model
1. M-> V 与 v-text类似
2. V->M 事件监听
