# 浮动
## 设计初衷
浮动能将一个元素（通常是一张图片）拉到其容器的一侧，这样文档流就能够包围它
## 容器折叠和浮动消除
- 浮动元素不同于普通文档流的元素，它们的高度不会加到父元素上
- 一个容器内的浮动元素会扩展到另一个容器，这样两个容器的文字就能围绕浮动元素排列
- 浏览器会将浮动元素尽可能地放在靠上的地方

### 伪元素
伪元素——一种特殊的选择器，可以选中文档的特定部分。伪元素以双冒号（::）开头，大部分浏览器为了向后兼容也支持单冒号的形式。最常见的伪元素是::before和::after，用来向元素的开始或者结束位置插入内容。
## 媒体对象
媒体对象模式：图片在左边，一段描述内容在右边
### BFC
一块特殊的区域
块级格式化上下文：
(1) 包含了内部所有元素的上下外边距。它们不会跟BFC外面的元素产生外边距折叠  --》解决margin塌陷。
(2) 包含了内部所有的浮动元素 --> 清除浮动。
(3) 不会跟BFC外面的浮动元素重叠  
给元素添加以下的任意属性值都会创建BFC。
- float： left或right，不为none即可。
- overflow：hidden、auto或scroll，不为visible即可。
- display：inline-block、table-cell、table-caption、flex、inline-flex、grid或inline-grid。拥
有这些属性的元素称为块级容器（block container）。
- position：absolute或position: fixed
## 网格系统
# Flex
给元素添加display:flex，该元素变成了一个弹性容器（flex container），它的直接子元素变成了弹性子元素（flex item）。弹性子元素默认是在同一行按照从左到右的顺序并排排列。弹性容器像块元素一样填满可用宽度，但是弹性子元素不一定填满其弹性容器的宽度。弹性子元素高度相等，该高度由它们的内容决定。
子元素按照主轴线排列，主轴的方向为主起点（左）到主终点（右）。垂直于主轴的是副轴。方向从副起点（上）到副终点（下）。这些轴的方向可以改变，
## 弹性子元素大小

### flex-basis

元素大小的基准值，可以是各种单位，当flex-basis 不是auto时，width 属性将会被忽略

### flex-grow

-   设定flex-basis可能不全占满整个空间，会有留白，多余的留白会按照flex-grow（增长因子）的直分配给每个弹性子元素。
-   为非负数
-   如果是0，则他们的宽度不会超过flex-basis的值
-   如果是非零会增长到所有的剩余空间被填满
-   felx-grow 越大权重越大，也会占据更大的剩余宽度
    -   flex-grow 为2的会比1 增大2倍
        

### flex-shrink

-   与flex-grow 想反这个值是超出后的收缩值
    
-   如果某个子元素为flex-shrink: 0,则不会收缩;如果值大于0, 则会收缩至不再溢出。按照 flex-shrink值的比例,值越大的元素收缩得越多。
    

### 实际用法

![](https://raw.githubusercontent.com/chenruida/image/master/202207071953953.png)

## 弹性方向

![](https://raw.githubusercontent.com/chenruida/image/master/202207072106446.png)
# 网格系统
## 构建

首先,使用display: grid定义一个网格容器。容器会表现得像一个块级元素,100%填充可用宽度。也可以使用inline-grid(尽管这段代码没写),这样元素就会在行内流动,且宽度只能够包含子元素,不过inline-grid的使用频率不高。 接下来是新属性:grid-template-columns和grid-templaterows。这两个属性定义了网格每行每列的大小。本例使用了一种新单位fr,代表每一列(或每一行)的分数单位(fraction unit)。这个单位跟Flexbox中flex-grow因子的表现一样。grid-templatecolumns: 1fr 1fr 1fr表示三列等宽。 不一定非得用分数单位,可以使用其他的单位,比如px、em或百分数。也可以混搭这几种单位,例如,grid-template-columns: 300px 1fr定义了一个固定宽度为300px的列,后面跟着一个会填满剩余可用空间的列。2fr的列宽是1fr的两倍。 最后,grid-gap属性定义了每个网格单元之间的间距。也可以用两个值分别指定垂直和水平方向的间距 ![](https://raw.githubusercontent.com/chenruida/image/master/202207072125124.png)

## 与Flexbox配合

- Flexbox本质上是一维的，而网格是二维的。
- Flexbox是以内容为切入点由内向外工作的，而网格是以布局为切入点从外向内工作的。
## 替代语法
### 命名网格线
```
grid-template-columns: [start] 2fr [center] 1fr [end];
grid-column: start / center;
grid-template-columns: [left-start] 2fr [left-end right-start] 1fr [right-end];
```
在这条声明里，2号网格线既叫作left-end也叫作right-start，之后可以任选一个名称使用。这里还有一个彩蛋：将网格线命名为left-start和left-end，就定义了一个叫作left的区域，这个区域覆盖两个网格线之间的区域。-start和-end后缀作为关键字，定义了两者之间的区域。
如果给元素设置grid-column: left，它就会跨越从left-start到left-end的区域。
### 命名网格区域
```
grid-template-areas:  "top top right"
											"left . right"
											"left bottom bottom"
```
### 隐式网络行

```
grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); ←---- 将最小列宽设置为200px，自动填充网格
grid-auto-rows: 1fr; ←----将隐式水平网格轨道的大小设置为1fr
grid-auto-flow: dense; ←---- 开启紧凑的网格布局算法
```
有时候我们不想给一个网格轨道设置固定尺寸，但是又希望限制它的最小值和最大值。这时候需要用到minmax()函数。它指定两个值：最小尺寸和最大尺寸。浏览器会确保网格轨道的大小介于这两者之间。（如果最大尺寸小于最小尺寸，最大尺寸就会被忽略。）通过指定minmax(200px,1fr)，浏览器确保了所有的轨道至少宽200px。
repeat()函数里的auto-fill关键字是一个特殊值。设置了之后，只要网格放得下，浏览器就会尽可能多地生成轨道，并且不会跟指定大小（minmax()值）的限制产生冲突。
auto-fill和minmax(200px, 1fr)加在一起，就会让网格在可用的空间内尽可能多地产生网格列，并且每个列的宽度不会小于200px。因为所有轨道的大小上限都为1fr（最大值），所以所有的网格轨道都等宽。
如果网格元素不够填满所有网格轨道，auto-fill就会导致一些空的网格轨道。如果不希望出现空的网格轨道，可以使用auto-fit关键字代替auto-fill。
## 特性查询
@supports规则后面跟着一个小括号包围的声明。如果浏览器理解这个声明（在本例中，浏览器支持网格），它就会使用大括号里面的所有样式规则。如果它不理解小括号里的声明，就不会使用这些样式规则。
## 对齐
![](https://raw.githubusercontent.com/chenruida/image/master/202207081451075.png)
- align-content属性指定了网格轨道如何在剩下的空间内分布。
- start——将网格轨道放到网格容器的上/左（Flexbox里则是flex-start）。
- end——将网格轨道放在网格容器的下/右（Flexbox里则是flex-end）。
- center——将网格轨道放在网格容器的中间。
- stretch——将网格轨道拉伸至填满网格容器。
- space-between——将剩余空间平均分配到每个网格轨道之间（它能覆盖任何grid-gap值）。
- space-around——将空间分配到每个网格轨道之间，且在两端各加上一半的间距。
- space-evenly——将空间分配到每个网格轨道之间，且在两端各加上同等大小的间距（Flexbox规范不支持）。
# 定位和层叠上下文
## 固定定位
- 给一个元素设置position: fixed就能将元素放在视口的任意位置。这需要搭配四种属性一起使用：top、right、bottom和left。这些属性的值决定了固定定位的元素与浏览器视口边缘的距离。
- 设置这四个值还隐式地定义了元素的宽高。比如指定left: 2em;right: 2em表示元素的左边缘距离视口左边2em，右边缘距离视口右边2em。因此元素的宽度等于视口总宽度减去4em。top、bottom和视口高度也是这样的关系。
### 用固定定位创建模态框
## 绝对定位
- 绝对定位不是相对窗口，而是相对最近的祖先定位元素。跟固定元素一样，属性top、right、bottom和left决定了元素的边缘在包含块里的位置。
- 同样可以改变元素的大小

## 相对定位
- position: relative
- 如果加上top、right、bottom和left属性，元素就会从原来的位置移走，但是不会改变它周围任何元素的位置。
- 跟固定或者绝对定位不一样，不能用top、right、bottom和left改变相对定位元素的大小。
- 这些值只能让元素在上、下、左、右方向移动。可以用top或者bottom，但它们不能一起用（bottom会被忽略）。同理，可以用left或right，但它们也不能一起用（right会被忽略）。
- 常见的用法是使用position:relative给它里面的绝对定位元素创建一个包含块。
### 创建下拉菜单
* 用JavaScript添加和移除一个控制菜单开关的类名。这样就能在打开和关闭菜单之前添加适当的延迟，防止用户在鼠标快速滑过时无意间触发:hover

## 层叠上下文和z-index
### z-index
- z-index只在定位元素上生效，不能用它控制静态元素
- 给一个定位元素加上z-index可以创建层叠上下文
### 层叠上下文
![](https://raw.githubusercontent.com/chenruida/image/master/202207081603824.png)
这段代码包含了三个盒子，其中两个被定位，并且z-index为1，第一个盒子里面有一个绝对定位的元素，它的z-index为100。虽然第一个盒子的z-index很高，但还是出现在第二个盒子后面，因为它的父元素，即第一个盒子形成的层叠上下文在第二个盒子后面
## 粘性定位
- poistion:sticky
- 正常情况下，元素会随着页面滚动，当到达屏幕的特定位置时，如果用户继续滚动，它就会“锁定”在这个位置。

# 响应式设计
## 三大原则
-  *移动优先。* 这意味着在实现桌面布局之前先构建移动版的布局。
- *@media。* 规则使用这个样式规则，可以为不同大小的视口定制样式。用这一语法，通常叫作媒体查询（media queries），写的样式只在特定条件下才会生效。
- *流式布局。* 这种方式允许容器根据视口宽度缩放尺寸。
## 移动优先
- 做响应式设计时，一定要确保HTML包含了各种屏幕尺寸所需的全部内容。你可以对每个屏幕尺寸应用不同的CSS，但是它们必须共享同一份HTML。
- 添加断点
	- 断点——一个特殊的临界值。屏幕尺寸达到这个值时，网页的样式会发生改变，以便给当前屏幕尺寸提供最佳的布局。
- meta标签。这个HTML标签告诉移动设备，你已经特意将网页适配了小屏设备。
	- 浏览器当解析CSS时将设备的宽度作为假定宽度，而不是一个全屏的桌面浏览器的宽度。
	-  当页面加载时，它使用initial-scale将缩放比设置为100%。
## 媒体查询
在最外层的大括号内可以定义任意的样式规则。@media规则会进行条件检查，只有满足所有的条件时，才会将这些样式应用到页面上。
- 临界值被称为断点
- 将两个条件用and关键字联合起来组成一个媒体查询
- 媒体特征
	- (min-height: 20em)——匹配高度大于等于20em的窗口。
	- (max-height: 20em)——匹配高度小于等于20em的窗口。
	- (orientation: landscape)——匹配宽度大于高度的窗口。
	- (orientation: portrait)——匹配高度大于宽度的窗口。
	- (min-resolution: 2dppx)——匹配屏幕分辨率大于等于2dppx（dppx指每个CSS像素里包含的物理像素点数）的设备，比如视网膜屏幕。
	- (max-resolution: 2dppx)——匹配屏幕分辨率小于等于2dppx的设备
- 媒体类型
	- 常见的两种媒体类型是screen和print。使用print媒体查询可以控制打印时的网页布局，这样就能在打印时去掉背景图（节省墨水），隐藏不必要的导航栏。
### 添加断点
最优先的是移动端样式，因为它们不在媒体查询里，所以这些样式对所有断点都有效。然后是针对中等屏幕的媒体查询，其中的规则基于移动端样式构建并且会覆盖移动端样式。最后是针对大屏幕的媒体查询，在这里添加网页最后的布局。
- max-width是用来排除某些规则的方式，而不是一个常规手段。
- 不需要覆盖移动样式里的top、left、right属性，因为它们对静态定位的元素不起作用。
### 添加响应的列
- 当设计要求元素并排摆放时，只在大屏上将它们摆放在一行。在小屏下，允许每个元素单独一行，填满屏幕宽度。
- https://bradfrost.github.io/this-is-responsive/patterns.html 
- 断点的选择

## 流式布局

- 使用的容器随视口宽度而变化。它跟固定布局相反，固定布局的列都是用px或者em单位定义。
- 在流式布局中，主页面容器通常不会有明确宽度，也不会给百分比宽度，但可能会设置左右内边距，或者设置左右外边距为auto，让其与视口边缘之间产生留白。也就是说容器可能比视口略窄，但永远不会比视口宽。
- 建议在移动设备上不选择列来组织数据。比如将每一行数据单独用一块区域展示，让每块区域顺序叠放，或者用更适合小屏的可视化图形或者图表展示。
	- 这个布局由`<table>、<tr>、<td>`元素组成，但是我们对它们使用了display: block声明，覆盖了正常的table、table-row、table-cell的显示值。可以用max-width媒体查询限制在小屏下才改变表格元素
## 响应式图片
- 在响应式设计中，图片需要特别关注。不仅要让图片适应屏幕，还要考虑移动端用户的带宽限制。图片通常是网页上最大的资源。首先要保证图片充分压缩。
- 响应式图片的最佳实践是为一个图片创建不同分辨率的副本。如果用媒体查询能够知道屏幕的大小，就不必发送过大的图片，不然浏览器为了适配图片也会将其缩小。
### 使用srcset提供对应的图片
![](https://raw.githubusercontent.com/chenruida/image/master/202207081653875.png)
