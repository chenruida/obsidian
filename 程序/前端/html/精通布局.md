# 浮动
## 设计初衷
浮动能将一个元素（通常是一张图片）拉到其容器的一侧，这样文档流就能够包围它
## 容器折叠和浮动消除
- 浮动元素不同于普通文档流的元素，它们的高度不会加到父元素上
- 一个容器内的浮动元素会扩展到另一个容器，这样两个容器的文字就能围绕浮动元素排列
- 浏览器会将浮动元素尽可能地放在靠上的地方

### 伪元素
伪元素——一种特殊的选择器，可以选中文档的特定部分。伪元素以双冒号（::）开头，大部分浏览器为了向后兼容也支持单冒号的形式。最常见的伪元素是::before和::after，用来向元素的开始或者结束位置插入内容。
## 媒体对象
媒体对象模式：图片在左边，一段描述内容在右边
### BFC
块级格式化上下文：
(1) 包含了内部所有元素的上下外边距。它们不会跟BFC外面的元素产生外边距折叠。
(2) 包含了内部所有的浮动元素。
(3) 不会跟BFC外面的浮动元素重叠
给元素添加以下的任意属性值都会创建BFC。
- float： left或right，不为none即可。
- overflow：hidden、auto或scroll，不为visible即可。
- display：inline-block、table-cell、table-caption、flex、inline-flex、grid或inline-grid。拥
有这些属性的元素称为块级容器（block container）。
- position：absolute或position: fixed
## 网格系统
# Flex
给元素添加display:flex，该元素变成了一个弹性容器（flex container），它的直接子元素变成了弹性子元素（flex item）。弹性子元素默认是在同一行按照从左到右的顺序并排排列。弹性容器像块元素一样填满可用宽度，但是弹性子元素不一定填满其弹性容器的宽度。弹性子元素高度相等，该高度由它们的内容决定。
子元素按照主轴线排列，主轴的方向为主起点（左）到主终点（右）。垂直于主轴的是副轴。方向从副起点（上）到副终点（下）。这些轴的方向可以改变，
## 弹性子元素大小

### flex-basis

元素大小的基准值，可以是各种单位，当flex-basis 不是auto时，width 属性将会被忽略

### flex-grow

-   设定flex-basis可能不全占满整个空间，会有留白，多余的留白会按照flex-grow（增长因子）的直分配给每个弹性子元素。
-   为非负数
-   如果是0，则他们的宽度不会超过flex-basis的值
-   如果是非零会增长到所有的剩余空间被填满
-   felx-grow 越大权重越大，也会占据更大的剩余宽度
    -   flex-grow 为2的会比1 增大2倍
        

### flex-shrink

-   与flex-grow 想反这个值是超出后的收缩值
    
-   如果某个子元素为flex-shrink: 0,则不会收缩;如果值大于0, 则会收缩至不再溢出。按照 flex-shrink值的比例,值越大的元素收缩得越多。
    

### 实际用法

![](https://raw.githubusercontent.com/chenruida/image/master/202207071953953.png)

## 弹性方向

![](https://raw.githubusercontent.com/chenruida/image/master/202207072106446.png)
# 网格系统
## 构建

首先,使用display: grid定义一个网格容器。容器会表现得像一个块级元素,100%填充可用宽度。也可以使用inline-grid(尽管这段代码没写),这样元素就会在行内流动,且宽度只能够包含子元素,不过inline-grid的使用频率不高。 接下来是新属性:grid-template-columns和grid-templaterows。这两个属性定义了网格每行每列的大小。本例使用了一种新单位fr,代表每一列(或每一行)的分数单位(fraction unit)。这个单位跟Flexbox中flex-grow因子的表现一样。grid-templatecolumns: 1fr 1fr 1fr表示三列等宽。 不一定非得用分数单位,可以使用其他的单位,比如px、em或百分数。也可以混搭这几种单位,例如,grid-template-columns: 300px 1fr定义了一个固定宽度为300px的列,后面跟着一个会填满剩余可用空间的列。2fr的列宽是1fr的两倍。 最后,grid-gap属性定义了每个网格单元之间的间距。也可以用两个值分别指定垂直和水平方向的间距 ![](https://raw.githubusercontent.com/chenruida/image/master/202207072125124.png)

## 与Flexbox配合

- Flexbox本质上是一维的，而网格是二维的。
- Flexbox是以内容为切入点由内向外工作的，而网格是以布局为切入点从外向内工作的。
## 替代语法
### 命名网格线
```
grid-template-columns: [start] 2fr [center] 1fr [end];
grid-column: start / center;
grid-template-columns: [left-start] 2fr [left-end right-start] 1fr [right-end];
```
在这条声明里，2号网格线既叫作left-end也叫作right-start，之后可以任选一个名称使用。这里还有一个彩蛋：将网格线命名为left-start和left-end，就定义了一个叫作left的区域，这个区域覆盖两个网格线之间的区域。-start和-end后缀作为关键字，定义了两者之间的区域。
如果给元素设置grid-column: left，它就会跨越从left-start到left-end的区域。
### 命名网格区域
```
grid-template-areas:  "top top right"
											"left . right"
											"left bottom bottom"
```
### 隐式网络行

```
grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); ←---- 将最小列宽设置为200px，自动填充网格
grid-auto-rows: 1fr; ←----将隐式水平网格轨道的大小设置为1fr
grid-auto-flow: dense; ←---- 开启紧凑的网格布局算法
```
有时候我们不想给一个网格轨道设置固定尺寸，但是又希望限制它的最小值和最大值。这时候需要用到minmax()函数。它指定两个值：最小尺寸和最大尺寸。浏览器会确保网格轨道的大小介于这两者之间。（如果最大尺寸小于最小尺寸，最大尺寸就会被忽略。）通过指定minmax(200px,1fr)，浏览器确保了所有的轨道至少宽200px。
repeat()函数里的auto-fill关键字是一个特殊值。设置了之后，只要网格放得下，浏览器就会尽可能多地生成轨道，并且不会跟指定大小（minmax()值）的限制产生冲突。
auto-fill和minmax(200px, 1fr)加在一起，就会让网格在可用的空间内尽可能多地产生网格列，并且每个列的宽度不会小于200px。因为所有轨道的大小上限都为1fr（最大值），所以所有的网格轨道都等宽。
如果网格元素不够填满所有网格轨道，auto-fill就会导致一些空的网格轨道。如果不希望出现空的网格轨道，可以使用auto-fit关键字代替auto-fill。
## 特性查询
@supports规则后面跟着一个小括号包围的声明。如果浏览器理解这个声明（在本例中，浏览器支持网格），它就会使用大括号里面的所有样式规则。如果它不理解小括号里的声明，就不会使用这些样式规则。
## 对齐
![](https://raw.githubusercontent.com/chenruida/image/master/202207081451075.png)
- align-content属性指定了网格轨道如何在剩下的空间内分布。
- start——将网格轨道放到网格容器的上/左（Flexbox里则是flex-start）。
- end——将网格轨道放在网格容器的下/右（Flexbox里则是flex-end）。
- center——将网格轨道放在网格容器的中间。
- stretch——将网格轨道拉伸至填满网格容器。
- space-between——将剩余空间平均分配到每个网格轨道之间（它能覆盖任何grid-gap值）。
- space-around——将空间分配到每个网格轨道之间，且在两端各加上一半的间距。
- space-evenly——将空间分配到每个网格轨道之间，且在两端各加上同等大小的间距（Flexbox规范不支持）。