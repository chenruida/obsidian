# 需求分析

## 结构分析模型

## 具体步骤

1. 发现需求
2. 求精
3. 建模
4. 规格说明
5. 复审

## 发现需求

1. 与用户交谈，向用户提问题
2. 参观用户的工作流程，观察用户的操作
3. 向用户群体发调查问卷
4. 与同行、专家交谈，听取他们的意见
5. 分析已存在的同类软件产品，提取需求（腾讯行为）
6. ==从行业标准、规则中提取需求==
7. 从网上找

## 求精

对初步需求反复求精多次细化

## ==建模==

- 文字有二义性，需要建模
- 模型由一个核心三个模型组成

### 一个核心

数据字典：描述软件使用和产生的所有数据对象

### 三个模型

#### 1. 数据模型

描述数据对象间关系

- 数据对象描述+实体联系图（E-R图）表示

#### 2.功能模型

描述数据在软件中移动、变换及相应功能

- 处理规格说明(图中功能)+数据流图（DF）表示

#### 3.行为模型

描述系统状态和在不同状态间转换方式

- 状态转换图
- 控制规格说明

## 规格说明

书写软件需求规格说明，作为分析阶段最终成果。（模版）

## 数据模型

### 数据对象

软件必须理解的复合信息表示，复合信息是具有一系列不同性质或属性的事物

### 数据对象间关系

对象彼此间相互连接方式，也叫联系。

分三类 1:1 1:N  M:N 

### 属性

定义数据对象性质

![image-20210318171210343](https://cdn.jsdelivr.net/gh/chenruida/image@master/uPic/image-20210318171210343ZmODkH.png)



## 功能模型

### 数据流图

#### 符号

正方形或立方体：表示数据的源点或终点

圆角矩形：变换数据的处理。一些列的程序或人工过程

开口矩形或平行线：代表数据存储

箭头：表示数据流，即特定的数据的流动方向

![image-20210318203935026](https://raw.githubusercontent.com/chenruida/image/master/img/image-20210318203935026.png)

#### 画法

1. 从问题描述中提取数据流图的四种成分
   1. 源点、终点
   2. 处理
   3. 数据流、数据存储

2. 着手画数据流图的基本系统模型
3. 把基本系统模型细化，描绘系统主要功能

### 分层数据流图

#### 1. 编号的设置

子图的编号是对父图相应的处理逻辑的编号

子图中处理逻辑编号由子图号，小数点 

#### 2. 父图与子图的平衡

子图详细描述父图中处理逻辑

子图的输入、输出数据流应同父图处理逻辑的输入、输出数据流相一致。

#### 3.局部数据存储

![image-20210318210433824](https://raw.githubusercontent.com/chenruida/image/master/img/image-20210318210433824.png)

### 命名规则

1. 数据流（数据存储）命名

   1. 用名词，区别与控制流
   2. 代表整个数据流内容，不仅仅反应某些成分
   3. 不用缺乏具体含义的名字，如'数据','信息'

2. 处理命名

   1. 用动宾词组，避免使用“加工”，”处理“等
   2. 应反应整个处理的功能，而不是一部分
   3. 通常仅包括一个动词，否则分解

3. 数据源点/终点

   ![image-20210318211229422](https://raw.githubusercontent.com/chenruida/image/master/img/image-20210318211229422.png)

## 行为模型

### 状态转换图

- 软件的行为模型：状态、事件、行为
  - 状态：被观察到的形体行为
  - 事件：引起状态转换的外界事件抽象
  - 行为：进入某状态所做的行为
- 图示
  - ![截屏2021-03-19 11.05.13](https://cdn.jsdelivr.net/gh/chenruida/image@master/uPic/%E6%88%AA%E5%B1%8F2021-03-19%2011.05.13sv9EUc.png)
  - ![image-20210319111152001](/Users/admin/Library/Application%20Support/typora-user-images/image-20210319111152001.png)
  - ![image-20210319111219030](https://cdn.jsdelivr.net/gh/chenruida/image@master/uPic/image-20210319111219030a45rZa.png)
- ![image-20210319112117270](https://cdn.jsdelivr.net/gh/chenruida/image@master/uPic/image-20210319112117270yGafBs.png)

## 数据字典

数据字典对四类元素定义：

1. 数据流
   1. 数据流名：
      1. 说明：简要介绍作用即它的产生的原因和结果
      2. 数据流的来源：数据流来自何方
      3. 数据流去向：去向何处
      4. 数据流的组成：数据结构
      5. 每个数据量流通量：数据量、流通量
2. 数据元素
   1. 数据元素名：
      1. 类型：数字（离散值、连续值） 文字
      2. 长度
      3. 取值范围
      4. 相关的数据元素及数据结构
3. 数据存储
   1. 数据存储名：
      1. 简述
      2. 输入数据：
      3. 输出数据：
      4. 数据文件组成：数据结构
      5. 存储方式：顺序、直接、关键码
      6. 存储频率
4. 处理
   1. 处理名：
      1. 处理编号：反映该处理的层次
      2. 简要描述：加工逻辑及功能简述
      3. 输入数据流
      4. 输出数据流
      5. 加工逻辑：简述加工程序、加工顺序

### 方法

对数据自顶向下分解

![image-20210319152549589](https://cdn.jsdelivr.net/gh/chenruida/image@master/uPic/image-202103191525495897NXJwN.png)

![image-20210319152701531](https://cdn.jsdelivr.net/gh/chenruida/image@master/uPic/image-20210319152701531o2fGvI.png)

## 结构化设计

![image-20210319154232170](/Users/admin/Library/Application%20Support/typora-user-images/image-20210319154232170.png)

### 1. 模块化

![image-20210319160519378](https://cdn.jsdelivr.net/gh/chenruida/image@master/uPic/image-202103191605193782V4UZj.png)

### 2. 抽象



### 3.逐步求精

继承

### 4.信息隐蔽

封装

### 5.模块独立

#### 耦合

软件结构之间不同模块间互连程度度量，取决于模块间接口复杂程度，通过接口数据。追求尽可能松散的耦合的系统

- 非直接耦合
- 数据耦合
- 控制耦合
  - 两模块通过参数交换控制信息
- 公共环境耦合
  - 两个或多个模块通过以公共数据环境作用
  - 一个模块送，一个模块取，等价于数据耦合
  - 两模块既往公共环境送又往里面取，介于数据耦合和控制耦合之间。
- 内容耦合 ==相当紧密，尽量避免==
  - 一个模块访问另一个模块内部数据
  - 一模块不通过正常入口进入另一模块内部
  - 两模块有程序代码重叠
  - 一模块多入口

==尽量使用数据耦合，少用控制耦合，限制公共环境耦合，完全不用内容耦合==

#### 内聚

模块内各元素彼此结合紧密程度

- 功能内聚
  - 一个模块中各部分是
- 顺序内聚
- 通信内聚
- 过程内聚
- 时间内聚
- 逻辑内聚

## 启发式规则

1. 改进软件结构提高模块独立性 软件结构要反复修正
2. 模块规模应该适中 
   - 过大分解不充分，但进一步分解不应降低模块独立性
   - 过小开销大于有效操作，模块数目过多系统接口复杂。
   - 通常语句行数在50～100，最多不超过500行
3. 深度、宽度、扇入和扇出应适当
   - 深度：软件结构纵向控制层数，标志一系统大小和复杂程度
   - 宽度：软件结构同一层模块数最大值，越大系统越复杂
   - 扇出： 一模块直接控制（调用）模块数 3-9之间最好
   - 扇入：有多少上级模块直接调用它，

4. 模块作用域应在控制域之内
   - 作用域：受该模块内判定影响的所有模块集合
   - 控制域：模块本身及所有直接或间接从属于它的模块集合
   - 不然会发生控制耦合
5. 降低模块接口复杂程度
6. 设计单入口、单出口的模块
7. 模块功能可预测



